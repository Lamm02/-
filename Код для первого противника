using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Boss : MonoBehaviour
{

    [SerializeField] private float HP=4f;
    [SerializeField] private float damageattack=1f;
    [SerializeField] private float rangeattack=3f;
    [SerializeField] private float cooldownattack=2f;
    [SerializeField] private float stunDuration = 1f;

    private Animator animator;
    private Rigidbody rb;
    private bool isAttacking = false;
    private bool canAttack = true;
    private AttackType currentAttack;



    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        if (HP<=0 || player==null) return;
        float distanceToPlayer = Vector3.Distance(transform.position, player.position);
        if (distanceToPlayer <= rangeattack && canAttack && !isAttacking)
        {
            chooseattack();
            Startcoroutine(attackroutine());

        }
        

    }

    public void chooseattack()
    {
        float randomValue = Random.value;

        if (randomValue < 0.4f) 
        {
            currentAttack = AttackType.Normal;
        }
        else if (randomValue < 0.7f) 
        {
            currentAttack = AttackType.Spin;
        }
        else 
        {
            currentAttack = AttackType.Jump;
        }
    }
    
    public void TakeDamage(float damage)
    {
        HP-=damage;
        if (HP<=0)
        {
            
            Die();
        }

    }
    void Die()
    {
        animator.SetTrigger("Die");
        GetComponent<Collider>().enabled = false;
        enabled = false;
        
        // Отключаем скрипт 
attackCollider.enabled = false;
        if (spinEffect) spinEffect.Stop();
    }
     void CheckForBarrelHitsDuringSpin()
    {
        // Проверяем бочек в радиусе вращения
        Collider[] hitBarrels = Physics.OverlapSphere(transform.position, attackRange, barrelLayer);
        foreach (Collider barrelCollider in hitBarrels)
        {
            if (barrelCollider.CompareTag("Barrel"))
            {
                BarrelHit(barrelCollider.gameObject);
            }
        }
    }

    void CheckForBarrelLanding()
    {
        // Проверяем бочек в радиусе приземления
        Collider[] hitBarrels = Physics.OverlapSphere(transform.position, jumpAttackRadius, barrelLayer);
        foreach (Collider barrelCollider in hitBarrels)
        {
            if (barrelCollider.CompareTag("Barrel"))
            {
                // При приземлении на бочку - взрыв
                BarrelHit(barrelCollider.gameObject);
                
                // Дополнительный эффект при приземлении
                if (hitEffect) hitEffect.Play();
            }
        }
    }

    void BarrelHit(GameObject barrel)
    {
        // Босс получает урон от бочки
        TakeDamage(barrelDamage);
        
        // Оглушение
        if (!isStunned)
        {
            StartCoroutine(StunRoutine());
        }
        
        // Взрыв бочки
        BarrelController barrelController = barrel.GetComponent<BarrelController>();
        if (barrelController != null)
        {
            barrelController.Explode();
        }
        
        Debug.Log("Босс попал по бочке и получил урон!");
    }

    IEnumerator StunRoutine()
    {
        isStunned = true;
        animator.SetBool("Stunned", true);
        
        // Останавливаем текущую атаку
        StopAllCoroutines();
        isAttacking = false;
        
        // Сбрасываем анимацию
        animator.SetTrigger("Hit");
        
        // Визуальный эффект оглушения
        StartCoroutine(StunEffect());
        
        yield return new WaitForSeconds(stunDuration);
        
        isStunned = false;
        animator.SetBool("Stunned", false);
    }

    IEnumerator StunEffect()
    {
        MeshRenderer renderer = GetComponent<MeshRenderer>();
        if (renderer == null) yield break;
        
        float timer = 0f;
        Material originalMaterial = renderer.material;
        Color originalColor = renderer.material.color;
        
        while (isStunned)
        {
            // Мигание при оглушении
            renderer.material.color = Color.Lerp(originalColor, Color.yellow, Mathf.PingPong(timer * 5f, 1f));
            timer += Time.deltaTime;
            yield return null;
        }
        
        renderer.material.color = originalColor;
    }
     void OnCollisionEnter(Collision collision)
    {
        // Дополнительная проверка столкновений с бочками
        if (collision.gameObject.CompareTag("Barrel") && isAttacking)
        {
            BarrelHit(collision.gameObject);
        }
    }

}
